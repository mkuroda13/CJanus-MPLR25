// Code generated by goyacc -o parser.go -p parser parser.y. DO NOT EDIT.

//line parser.y:2
package main

import __yyfmt__ "fmt"

//line parser.y:2

import (
	"strconv"
)

//line parser.y:9
type parserSymType struct {
	yys      int
	num      int
	ident    string
	varid    string
	tag      int
	arrentry arrentry
}

const NUM = 57346
const IDENT = 57347
const PLUS = 57348
const MINUS = 57349
const XOR = 57350
const MULT = 57351
const DIV = 57352
const MOD = 57353
const AND = 57354
const OR = 57355
const BITAND = 57356
const BITOR = 57357
const LEQ = 57358
const GEQ = 57359
const NEQ = 57360
const EQ = 57361
const LES = 57362
const GRT = 57363
const LSB = 57364
const RSB = 57365
const LCB = 57366
const RCB = 57367
const COMMA = 57368
const LPR = 57369
const RPR = 57370
const PROCEDURE = 57371
const MAIN = 57372
const INT = 57373
const IF = 57374
const THEN = 57375
const ELSE = 57376
const FI = 57377
const FROM = 57378
const DO = 57379
const LOOP = 57380
const UNTIL = 57381
const LOCAL = 57382
const DELOCAL = 57383
const CALL = 57384
const UNCALL = 57385
const SKIP = 57386
const BEGIN = 57387
const END = 57388
const P = 57389
const V = 57390
const SYNC = 57391
const WAIT = 57392
const ACQUIRE = 57393

var parserToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"NUM",
	"IDENT",
	"PLUS",
	"MINUS",
	"XOR",
	"MULT",
	"DIV",
	"MOD",
	"AND",
	"OR",
	"BITAND",
	"BITOR",
	"LEQ",
	"GEQ",
	"NEQ",
	"EQ",
	"LES",
	"GRT",
	"LSB",
	"RSB",
	"LCB",
	"RCB",
	"COMMA",
	"LPR",
	"RPR",
	"PROCEDURE",
	"MAIN",
	"INT",
	"IF",
	"THEN",
	"ELSE",
	"FI",
	"FROM",
	"DO",
	"LOOP",
	"UNTIL",
	"LOCAL",
	"DELOCAL",
	"CALL",
	"UNCALL",
	"SKIP",
	"BEGIN",
	"END",
	"P",
	"V",
	"SYNC",
	"WAIT",
	"ACQUIRE",
}

var parserStatenames = [...]string{}

const parserEofCode = 1
const parserErrCode = 2
const parserInitialStackSize = 16

//line parser.y:670

//line yacctab:1
var parserExca = [...]int8{
	-1, 1,
	1, -1,
	-2, 0,
}

const parserPrivate = 57344

const parserLast = 215

var parserAct = [...]uint8{
	94, 184, 185, 171, 13, 165, 99, 46, 107, 97,
	14, 86, 80, 67, 68, 9, 96, 14, 100, 36,
	24, 98, 95, 188, 203, 197, 187, 202, 193, 182,
	192, 62, 69, 10, 119, 6, 44, 170, 85, 139,
	64, 65, 198, 51, 172, 108, 87, 26, 55, 160,
	114, 27, 37, 38, 39, 29, 83, 28, 110, 20,
	70, 71, 72, 101, 45, 31, 30, 88, 40, 63,
	119, 84, 50, 119, 58, 102, 103, 104, 57, 119,
	141, 59, 60, 118, 89, 111, 56, 54, 14, 53,
	112, 52, 115, 116, 117, 120, 77, 78, 41, 42,
	43, 113, 135, 121, 122, 124, 123, 125, 126, 109,
	127, 128, 130, 136, 105, 106, 195, 7, 140, 129,
	166, 138, 131, 132, 133, 142, 32, 134, 64, 65,
	143, 146, 147, 148, 149, 150, 151, 145, 156, 157,
	158, 159, 144, 137, 161, 162, 81, 163, 167, 152,
	153, 154, 155, 4, 90, 82, 49, 48, 34, 11,
	33, 12, 79, 61, 164, 201, 181, 173, 47, 174,
	169, 206, 194, 183, 177, 175, 179, 199, 176, 190,
	180, 178, 168, 76, 186, 75, 74, 73, 14, 191,
	189, 93, 92, 91, 23, 196, 22, 21, 19, 200,
	18, 17, 204, 205, 16, 15, 66, 207, 35, 8,
	3, 5, 2, 1, 25,
}

var parserPact = [...]int16{
	-1000, -1000, 6, -16, -1000, 6, 156, 15, -16, 155,
	153, -1000, -1000, -1000, 15, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, 46, 92, -1000, -1000, -1000, -1000,
	152, 151, -1000, 50, -1000, 16, -1000, 72, 70, 68,
	-1000, 67, 59, 55, -1000, -1000, -1000, 0, -1000, -1000,
	124, -17, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, 141, 150, 33, -1000, 49, 10, 20, 62, 149,
	-1000, -1000, -1000, 36, 36, 36, 36, -1000, -1000, -1000,
	19, -1000, 39, -1000, 36, 15, -1000, -17, -1000, 27,
	-1000, 36, 36, 36, 60, 83, 87, 104, 113, -1000,
	-1000, 36, 66, 66, 66, -1000, -1000, -1000, 141, 12,
	-1000, 57, -1000, 20, 125, 66, 66, 66, -1000, 36,
	36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
	36, 36, 36, 36, 36, 21, -1000, -1000, 19, 115,
	-1000, -1000, -1000, -1000, 83, 87, 104, 104, 104, 104,
	104, 104, 113, 113, 113, 113, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, 9, 18, -1000, -1000, 36, -1000,
	-1000, -1000, 115, 36, 66, 36, 18, 66, -4, 66,
	-1000, 15, 15, -11, -18, 15, -1000, 15, -1, -1000,
	-6, -1000, 111, 15, -13, 23, -1000, 15, -1000, -8,
	-15, 36, 36, -1000, 66, 66, 36, 66,
}

var parserPgo = [...]uint8{
	0, 18, 0, 22, 16, 9, 21, 6, 36, 214,
	7, 213, 212, 153, 211, 210, 117, 4, 209, 208,
	206, 13, 11, 2, 1, 205, 204, 201, 200, 198,
	197, 196, 194, 193, 192, 191, 187, 186, 185, 183,
	182, 181, 179, 177, 175, 173, 172, 171, 168, 167,
	166, 165, 164, 5, 3, 163, 162, 12, 109, 8,
}

var parserR1 = [...]int8{
	0, 11, 13, 13, 15, 12, 16, 16, 18, 18,
	18, 19, 14, 20, 20, 22, 22, 21, 21, 21,
	17, 17, 24, 23, 23, 23, 23, 23, 23, 23,
	23, 23, 33, 25, 34, 25, 35, 25, 36, 9,
	37, 26, 38, 26, 39, 26, 40, 41, 42, 43,
	27, 8, 44, 45, 46, 47, 28, 48, 49, 50,
	51, 30, 52, 52, 54, 54, 53, 31, 32, 55,
	29, 58, 57, 56, 59, 59, 10, 2, 2, 3,
	3, 4, 4, 4, 4, 4, 4, 4, 5, 5,
	5, 5, 5, 6, 6, 6, 6, 6, 7, 7,
	1, 1, 1,
}

var parserR2 = [...]int8{
	0, 2, 2, 0, 0, 3, 2, 0, 2, 2,
	5, 0, 7, 2, 0, 3, 0, 2, 4, 2,
	2, 0, 2, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 0, 6, 0, 6, 0, 6, 0, 6,
	0, 5, 0, 5, 0, 5, 0, 0, 0, 0,
	18, 0, 0, 0, 0, 0, 19, 0, 0, 0,
	0, 17, 2, 0, 3, 0, 1, 2, 2, 0,
	4, 0, 5, 2, 3, 0, 0, 1, 3, 1,
	3, 1, 3, 3, 3, 3, 3, 3, 1, 3,
	3, 3, 3, 1, 3, 3, 3, 3, 1, 3,
	1, 1, 4,
}

var parserChk = [...]int16{
	-1000, -11, -12, -15, -13, -14, 29, -16, -18, 31,
	49, -13, 5, -17, -23, -25, -26, -27, -28, -29,
	44, -30, -31, -32, 5, -9, 32, 36, 42, 40,
	51, 50, -16, 5, 5, -19, -17, 6, 7, 8,
	22, 6, 7, 8, -8, -8, -10, -48, 5, 5,
	22, 27, 19, 19, 19, -10, 19, 19, 19, -8,
	-8, -55, 31, -1, 4, 5, -20, -21, 31, 49,
	-10, -10, -10, -36, -37, -38, -39, -8, -8, -56,
	-57, 5, 5, 23, 22, 28, -22, 26, 5, 22,
	5, -33, -34, -35, -2, -3, -4, -5, -6, -7,
	-1, 27, -2, -2, -2, -8, -8, -59, 26, -58,
	19, -2, -17, -21, 23, -2, -2, -2, 23, 13,
	12, 16, 17, 19, 18, 20, 21, 6, 7, 15,
	8, 9, 10, 11, 14, -2, -10, -8, -57, 27,
	-10, 23, -22, 5, -3, -4, -5, -5, -5, -5,
	-5, -5, -6, -6, -6, -6, -7, -7, -7, -7,
	28, -10, -10, -59, -52, -53, 5, -10, -40, -10,
	28, -54, 26, -49, -2, -44, -53, -2, -41, -2,
	-54, -50, 33, -45, -24, -23, -24, 37, 41, -17,
	-42, -24, 31, 34, -46, 5, -24, 38, 19, -43,
	-24, -51, 35, 39, -2, -2, -47, -2,
}

var parserDef = [...]int8{
	4, -2, 3, 7, 1, 3, 0, 21, 7, 0,
	0, 2, 11, 5, 21, 23, 24, 25, 26, 27,
	28, 29, 30, 31, 0, 0, 51, 51, 76, 57,
	0, 0, 6, 8, 9, 0, 20, 0, 0, 0,
	76, 0, 0, 0, 51, 51, 69, 0, 67, 68,
	0, 14, 76, 76, 76, 38, 40, 42, 44, 51,
	51, 0, 0, 0, 100, 101, 0, 16, 0, 0,
	32, 34, 36, 0, 0, 0, 0, 51, 51, 70,
	75, 71, 0, 10, 0, 21, 13, 0, 17, 0,
	19, 0, 0, 0, 0, 77, 79, 81, 88, 93,
	98, 0, 41, 43, 45, 76, 51, 73, 0, 0,
	76, 0, 12, 16, 0, 33, 35, 37, 39, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 76, 76, 75, 63,
	76, 102, 15, 18, 78, 80, 82, 83, 84, 85,
	86, 87, 89, 90, 91, 92, 94, 95, 96, 97,
	99, 46, 76, 74, 0, 65, 66, 58, 0, 52,
	72, 62, 0, 0, 47, 0, 65, 59, 0, 53,
	64, 0, 0, 0, 0, 21, 48, 0, 0, 22,
	0, 54, 0, 0, 0, 0, 49, 0, 60, 0,
	0, 0, 0, 55, 61, 50, 0, 56,
}

var parserTok1 = [...]int8{
	1,
}

var parserTok2 = [...]int8{
	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
	42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
}

var parserTok3 = [...]int8{
	0,
}

var parserErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	parserDebug        = 0
	parserErrorVerbose = false
)

type parserLexer interface {
	Lex(lval *parserSymType) int
	Error(s string)
}

type parserParser interface {
	Parse(parserLexer) int
	Lookahead() int
}

type parserParserImpl struct {
	lval  parserSymType
	stack [parserInitialStackSize]parserSymType
	char  int
}

func (p *parserParserImpl) Lookahead() int {
	return p.char
}

func parserNewParser() parserParser {
	return &parserParserImpl{}
}

const parserFlag = -1000

func parserTokname(c int) string {
	if c >= 1 && c-1 < len(parserToknames) {
		if parserToknames[c-1] != "" {
			return parserToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func parserStatname(s int) string {
	if s >= 0 && s < len(parserStatenames) {
		if parserStatenames[s] != "" {
			return parserStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func parserErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !parserErrorVerbose {
		return "syntax error"
	}

	for _, e := range parserErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + parserTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := int(parserPact[state])
	for tok := TOKSTART; tok-1 < len(parserToknames); tok++ {
		if n := base + tok; n >= 0 && n < parserLast && int(parserChk[int(parserAct[n])]) == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if parserDef[state] == -2 {
		i := 0
		for parserExca[i] != -1 || int(parserExca[i+1]) != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; parserExca[i] >= 0; i += 2 {
			tok := int(parserExca[i])
			if tok < TOKSTART || parserExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if parserExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += parserTokname(tok)
	}
	return res
}

func parserlex1(lex parserLexer, lval *parserSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = int(parserTok1[0])
		goto out
	}
	if char < len(parserTok1) {
		token = int(parserTok1[char])
		goto out
	}
	if char >= parserPrivate {
		if char < parserPrivate+len(parserTok2) {
			token = int(parserTok2[char-parserPrivate])
			goto out
		}
	}
	for i := 0; i < len(parserTok3); i += 2 {
		token = int(parserTok3[i+0])
		if token == char {
			token = int(parserTok3[i+1])
			goto out
		}
	}

out:
	if token == 0 {
		token = int(parserTok2[1]) /* unknown char */
	}
	if parserDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", parserTokname(token), uint(char))
	}
	return char, token
}

func parserParse(parserlex parserLexer) int {
	return parserNewParser().Parse(parserlex)
}

func (parserrcvr *parserParserImpl) Parse(parserlex parserLexer) int {
	var parsern int
	var parserVAL parserSymType
	var parserDollar []parserSymType
	_ = parserDollar // silence set and not used
	parserS := parserrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	parserstate := 0
	parserrcvr.char = -1
	parsertoken := -1 // parserrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		parserstate = -1
		parserrcvr.char = -1
		parsertoken = -1
	}()
	parserp := -1
	goto parserstack

ret0:
	return 0

ret1:
	return 1

parserstack:
	/* put a state and value onto the stack */
	if parserDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", parserTokname(parsertoken), parserStatname(parserstate))
	}

	parserp++
	if parserp >= len(parserS) {
		nyys := make([]parserSymType, len(parserS)*2)
		copy(nyys, parserS)
		parserS = nyys
	}
	parserS[parserp] = parserVAL
	parserS[parserp].yys = parserstate

parsernewstate:
	parsern = int(parserPact[parserstate])
	if parsern <= parserFlag {
		goto parserdefault /* simple state */
	}
	if parserrcvr.char < 0 {
		parserrcvr.char, parsertoken = parserlex1(parserlex, &parserrcvr.lval)
	}
	parsern += parsertoken
	if parsern < 0 || parsern >= parserLast {
		goto parserdefault
	}
	parsern = int(parserAct[parsern])
	if int(parserChk[parsern]) == parsertoken { /* valid shift */
		parserrcvr.char = -1
		parsertoken = -1
		parserVAL = parserrcvr.lval
		parserstate = parsern
		if Errflag > 0 {
			Errflag--
		}
		goto parserstack
	}

parserdefault:
	/* default state action */
	parsern = int(parserDef[parserstate])
	if parsern == -2 {
		if parserrcvr.char < 0 {
			parserrcvr.char, parsertoken = parserlex1(parserlex, &parserrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if parserExca[xi+0] == -1 && int(parserExca[xi+1]) == parserstate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			parsern = int(parserExca[xi+0])
			if parsern < 0 || parsern == parsertoken {
				break
			}
		}
		parsern = int(parserExca[xi+1])
		if parsern < 0 {
			goto ret0
		}
	}
	if parsern == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			parserlex.Error(parserErrorMessage(parserstate, parsertoken))
			Nerrs++
			if parserDebug >= 1 {
				__yyfmt__.Printf("%s", parserStatname(parserstate))
				__yyfmt__.Printf(" saw %s\n", parserTokname(parsertoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for parserp >= 0 {
				parsern = int(parserPact[parserS[parserp].yys]) + parserErrCode
				if parsern >= 0 && parsern < parserLast {
					parserstate = int(parserAct[parsern]) /* simulate a shift of "error" */
					if int(parserChk[parserstate]) == parserErrCode {
						goto parserstack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if parserDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", parserS[parserp].yys)
				}
				parserp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if parserDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", parserTokname(parsertoken))
			}
			if parsertoken == parserEofCode {
				goto ret1
			}
			parserrcvr.char = -1
			parsertoken = -1
			goto parsernewstate /* try again in the same state */
		}
	}

	/* reduction by production parsern */
	if parserDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", parsern, parserStatname(parserstate))
	}

	parsernt := parsern
	parserpt := parserp
	_ = parserpt // guard against "declared and not used"

	parserp -= int(parserR2[parsern])
	// parserp is now the index of $0. Perform the default action. Iff the
	// reduced production is ε, $1 is possibly out of range.
	if parserp+1 >= len(parserS) {
		nyys := make([]parserSymType, len(parserS)*2)
		copy(nyys, parserS)
		parserS = nyys
	}
	parserVAL = parserS[parserp+1]

	/* consult goto table to find next state */
	parsern = int(parserR1[parsern])
	parserg := int(parserPgo[parsern])
	parserj := parserg + parserS[parserp].yys + 1

	if parserj >= parserLast {
		parserstate = int(parserAct[parserg])
	} else {
		parserstate = int(parserAct[parserj])
		if int(parserChk[parserstate]) != -parsern {
			parserstate = int(parserAct[parserg])
		}
	}
	// dummy call; replaced with literal code
	switch parsernt {

	case 4:
		parserDollar = parserS[parserpt-0 : parserpt+1]
//line parser.y:31
		{
			if !prep {
				cmp.exec("begin main")
			}
		}
	case 5:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:38
		{
			if !prep {
				cmp.exec("end main")
			}
		}
	case 8:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:49
		{
			if !prep {
				cmp.registerGlobal(parserDollar[2].ident, T_INT)
				cmp.exec("set #" + parserDollar[2].ident + " " + cmp.getMem(1))
			}
		}
	case 9:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:55
		{
			if !prep {
				cmp.registerGlobal(parserDollar[2].ident, T_SYNC)
				cmp.exec("set #" + parserDollar[2].ident + " " + cmp.getMem(1))
			}
		}
	case 10:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:62
		{
			if !prep {
				cmp.registerGlobal(parserDollar[2].ident, T_INTA)
				size, _ := strconv.Atoi(parserDollar[4].varid)
				cmp.exec("set #" + parserDollar[2].ident + " " + cmp.getMem(size))
			}
		}
	case 11:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:71
		{
			if prep {
				cmp.declpname = parserDollar[2].ident
			} else {
				cmp.setProc(parserDollar[2].ident)
				cmp.exec("begin " + parserDollar[2].ident)
			}
		}
	case 12:
		parserDollar = parserS[parserpt-7 : parserpt+1]
//line parser.y:80
		{
			if !prep {
				cmp.exec("end " + parserDollar[2].ident)
			}
		}
	case 17:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:94
		{
			if prep {
				cmp.registerDecl(parserDollar[2].ident, T_INT)
			}
		}
	case 18:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:100
		{
			if prep {
				cmp.registerDecl(parserDollar[4].ident, T_INTA)
			}
		}
	case 19:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:106
		{
			if prep {
				cmp.registerDecl(parserDollar[2].ident, T_SYNC)
			}
		}
	case 32:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:128
		{
			if !prep {
				cmp.beginRecord(parserDollar[4].tag)
			}
		}
	case 33:
		parserDollar = parserS[parserpt-6 : parserpt+1]
//line parser.y:134
		{
			if !prep {
				cmp.endRecord(parserDollar[4].tag)
				cmp.lockrecord(parserDollar[4].tag)
				cmp.execrecord(parserDollar[4].tag)
				cmp.exec(parserDollar[1].ident + " += " + parserDollar[6].varid)
				cmp.unexecrecord(parserDollar[4].tag)
				cmp.unlockrecord(parserDollar[4].tag)
			}

		}
	case 34:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:146
		{
			if !prep {
				cmp.beginRecord(parserDollar[4].tag)
			}
		}
	case 35:
		parserDollar = parserS[parserpt-6 : parserpt+1]
//line parser.y:152
		{
			if !prep {
				cmp.endRecord(parserDollar[4].tag)
				cmp.lockrecord(parserDollar[4].tag)
				cmp.execrecord(parserDollar[4].tag)
				cmp.exec(parserDollar[1].ident + " -= " + parserDollar[6].varid)
				cmp.unexecrecord(parserDollar[4].tag)
				cmp.unlockrecord(parserDollar[4].tag)
			}

		}
	case 36:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:164
		{
			if !prep {
				cmp.beginRecord(parserDollar[4].tag)
			}
		}
	case 37:
		parserDollar = parserS[parserpt-6 : parserpt+1]
//line parser.y:170
		{
			if !prep {
				cmp.endRecord(parserDollar[4].tag)
				cmp.lockrecord(parserDollar[4].tag)
				cmp.execrecord(parserDollar[4].tag)
				cmp.exec(parserDollar[1].ident + " ^= " + parserDollar[6].varid)
				cmp.unexecrecord(parserDollar[4].tag)
				cmp.unlockrecord(parserDollar[4].tag)
			}

		}
	case 38:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:183
		{
			if !prep {
				cmp.beginRecord(parserDollar[3].tag)
			}
		}
	case 39:
		parserDollar = parserS[parserpt-6 : parserpt+1]
//line parser.y:189
		{
			if !prep {
				cmp.endRecord(parserDollar[3].tag)
				parserVAL.arrentry = arrentry{parserDollar[1].ident + "[" + parserDollar[5].varid + "]", parserDollar[3].tag}
			}
		}
	case 40:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:197
		{
			if !prep {
				cmp.beginRecord(parserDollar[1].arrentry.tag)
			}
		}
	case 41:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:203
		{
			if !prep {
				cmp.endRecord(parserDollar[1].arrentry.tag)
				cmp.lockrecord(parserDollar[1].arrentry.tag)
				cmp.execrecord(parserDollar[1].arrentry.tag)
				cmp.exec(parserDollar[1].arrentry.val + " += " + parserDollar[5].varid)
				cmp.unexecrecord(parserDollar[1].arrentry.tag)
				cmp.unlockrecord(parserDollar[1].arrentry.tag)
			}

		}
	case 42:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:215
		{
			if !prep {
				cmp.beginRecord(parserDollar[1].arrentry.tag)
			}
		}
	case 43:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:221
		{
			if !prep {
				cmp.endRecord(parserDollar[1].arrentry.tag)
				cmp.lockrecord(parserDollar[1].arrentry.tag)
				cmp.execrecord(parserDollar[1].arrentry.tag)
				cmp.exec(parserDollar[1].arrentry.val + " -= " + parserDollar[5].varid)
				cmp.unexecrecord(parserDollar[1].arrentry.tag)
				cmp.unlockrecord(parserDollar[1].arrentry.tag)
			}

		}
	case 44:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:233
		{
			if !prep {
				cmp.beginRecord(parserDollar[1].arrentry.tag)
			}
		}
	case 45:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:239
		{
			if !prep {
				cmp.endRecord(parserDollar[1].arrentry.tag)
				cmp.lockrecord(parserDollar[1].arrentry.tag)
				cmp.execrecord(parserDollar[1].arrentry.tag)
				cmp.exec(parserDollar[1].arrentry.val + " ^= " + parserDollar[5].varid)
				cmp.unexecrecord(parserDollar[1].arrentry.tag)
				cmp.unlockrecord(parserDollar[1].arrentry.tag)
			}

		}
	case 46:
		parserDollar = parserS[parserpt-7 : parserpt+1]
//line parser.y:252
		{
			if !prep {
				cmp.beginRecord(parserDollar[6].tag)
			}
		}
	case 47:
		parserDollar = parserS[parserpt-9 : parserpt+1]
//line parser.y:258
		{
			if !prep {
				cmp.endRecord(parserDollar[6].tag)
				cmp.lockrecord(parserDollar[6].tag)
				cmp.execrecord(parserDollar[6].tag)
				cmp.exec(parserDollar[9].varid + " -> " + parserDollar[2].varid + ";" + parserDollar[3].varid)
				cmp.exec(parserDollar[2].varid + " <-")
				cmp.unexecrecord(parserDollar[6].tag)
				cmp.unlockrecord(parserDollar[6].tag)
			}
		}
	case 48:
		parserDollar = parserS[parserpt-12 : parserpt+1]
//line parser.y:270
		{
			if !prep {
				cmp.lockrecord(parserDollar[7].tag)
				cmp.execrecord(parserDollar[7].tag)
				cmp.exec("-> " + parserDollar[4].varid)
				cmp.exec(parserDollar[3].varid + " <-")
				cmp.unexecrecord(parserDollar[6].tag)
				cmp.unlockrecord(parserDollar[6].tag)
			}
		}
	case 49:
		parserDollar = parserS[parserpt-15 : parserpt+1]
//line parser.y:281
		{
			if !prep {
				cmp.lockrecord(parserDollar[7].tag)
				cmp.execrecord(parserDollar[7].tag)
				cmp.exec("-> " + parserDollar[5].varid)
				cmp.beginRecord(parserDollar[7].tag)
			}
		}
	case 50:
		parserDollar = parserS[parserpt-18 : parserpt+1]
//line parser.y:290
		{
			if !prep {
				cmp.endRecord(parserDollar[7].tag)
				cmp.exec(parserDollar[4].varid + ";" + parserDollar[5].varid + " <- " + parserDollar[18].varid)
				cmp.unexecrecord(parserDollar[7].tag)
				cmp.unlockrecord(parserDollar[7].tag)
			}
		}
	case 51:
		parserDollar = parserS[parserpt-0 : parserpt+1]
//line parser.y:300
		{
			if !prep {
				parserVAL.varid = cmp.getLabel()
			}
		}
	case 52:
		parserDollar = parserS[parserpt-8 : parserpt+1]
//line parser.y:307
		{
			if !prep {
				cmp.beginRecord(parserDollar[7].tag)
			}
		}
	case 53:
		parserDollar = parserS[parserpt-10 : parserpt+1]
//line parser.y:313
		{
			if !prep {
				cmp.endRecord(parserDollar[7].tag)
				cmp.lockrecord(parserDollar[7].tag)
				cmp.execrecord(parserDollar[7].tag)
				cmp.exec("-> " + parserDollar[2].varid)
				cmp.exec(parserDollar[2].varid + ";" + parserDollar[6].varid + " <- " + parserDollar[10].varid)
				cmp.unexecrecord(parserDollar[7].tag)
				cmp.unlockrecord(parserDollar[7].tag)
			}
		}
	case 54:
		parserDollar = parserS[parserpt-13 : parserpt+1]
//line parser.y:325
		{
			if !prep {
				cmp.exec("-> " + parserDollar[3].varid)
				cmp.exec(parserDollar[5].varid + " <-")
				cmp.unexecrecord(parserDollar[8].tag)
				cmp.unlockrecord(parserDollar[8].tag)
			}
		}
	case 55:
		parserDollar = parserS[parserpt-17 : parserpt+1]
//line parser.y:334
		{
			if !prep {
				cmp.lockrecord(parserDollar[7].tag)
				cmp.execrecord(parserDollar[7].tag)
				cmp.exec("-> " + parserDollar[6].varid)
				cmp.exec(parserDollar[3].varid + " <-")
				cmp.beginRecord(parserDollar[8].tag)
			}
		}
	case 56:
		parserDollar = parserS[parserpt-19 : parserpt+1]
//line parser.y:344
		{
			if !prep {
				cmp.endRecord(parserDollar[8].tag)
				cmp.lockrecord(parserDollar[8].tag)
				cmp.execrecord(parserDollar[8].tag)
				cmp.exec(parserDollar[19].varid + " -> " + parserDollar[4].varid + ";" + parserDollar[5].varid)
				cmp.exec(parserDollar[4].varid + " <-")
				cmp.unexecrecord(parserDollar[8].tag)
				cmp.unlockrecord(parserDollar[8].tag)
			}
		}
	case 57:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:358
		{
			if !prep {
				cmp.exec("push")
				cmp.indent()
			}
		}
	case 58:
		parserDollar = parserS[parserpt-7 : parserpt+1]
//line parser.y:365
		{
			if !prep {
				cmp.registerLocal(parserDollar[4].ident)
				cmp.beginRecord(parserDollar[6].tag)
			}
		}
	case 59:
		parserDollar = parserS[parserpt-9 : parserpt+1]
//line parser.y:372
		{
			if !prep {
				cmp.endRecord(parserDollar[6].tag)
				cmp.lockrecord(parserDollar[6].tag)
				cmp.execrecord(parserDollar[6].tag)
				cmp.exec("$" + parserDollar[4].ident + " += " + parserDollar[9].varid)
				cmp.unexecrecord(parserDollar[6].tag)
				cmp.unlockrecord(parserDollar[6].tag)
			}
		}
	case 60:
		parserDollar = parserS[parserpt-15 : parserpt+1]
//line parser.y:383
		{
			if !prep {
				cmp.beginRecord(parserDollar[7].tag)
			}
		}
	case 61:
		parserDollar = parserS[parserpt-17 : parserpt+1]
//line parser.y:389
		{
			if !prep {
				cmp.endRecord(parserDollar[7].tag)
				cmp.lockrecord(parserDollar[7].tag)
				cmp.execrecord(parserDollar[7].tag)
				cmp.exec("$" + parserDollar[14].ident + " -= " + parserDollar[17].varid)
				cmp.unexecrecord(parserDollar[7].tag)
				cmp.unlockrecord(parserDollar[7].tag)
				cmp.exec("pop")
				cmp.unindent()
			}
		}
	case 66:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:410
		{
			if !prep {
				i, t := cmp.getProcArgs(cmp.callpname)
				t[cmp.argindex].match(cmp.typeOf(parserDollar[1].ident))
				cmp.exec("set $" + i[cmp.argindex] + "@" + strconv.Itoa(len(cmp.procrec)-1) + " " + parserDollar[1].ident)
				cmp.unexec("unset $" + i[cmp.argindex] + "@" + strconv.Itoa(len(cmp.procrec)-1) + " " + parserDollar[1].ident)
				cmp.argindex++
			}
		}
	case 67:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:421
		{
			if !prep {
				cmp.exec("V " + parserDollar[2].ident)
			}
		}
	case 68:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:427
		{
			if !prep {
				cmp.exec("P " + parserDollar[2].ident)
			}
		}
	case 69:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:434
		{
			if !prep {
				cmp.procrec = make([]string, 0)
				cmp.beginRecord(parserDollar[2].tag)
			}
		}
	case 70:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:441
		{
			if !prep {
				cmp.endRecord(parserDollar[2].tag)
				cmp.execrecord(parserDollar[2].tag)
				s := ""
				for i, p := range cmp.procrec {
					if i != 0 {
						s += ", "
					}
					s += p
				}
				cmp.exec("call " + s)
				cmp.unexecrecord(parserDollar[2].tag)
				cmp.procrec = make([]string, 0)
			}
		}
	case 71:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:459
		{
			if !prep {
				cmp.callpname = parserDollar[1].ident
				cmp.procrec = append(cmp.procrec, parserDollar[1].ident)
				cmp.argindex = 0
			}
		}
	case 72:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:467
		{
			if !prep {
				cmp.argindex = 0
			}
		}
	case 76:
		parserDollar = parserS[parserpt-0 : parserpt+1]
//line parser.y:479
		{
			parserVAL.tag = cmp.getTag()
		}
	case 77:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:484
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 78:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:488
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " ||" + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " ||" + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 79:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:497
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 80:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:501
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " && " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " && " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 81:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:511
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 82:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:515
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " <= " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " <= " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 83:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:524
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " >= " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " >= " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 84:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:533
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " == " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " == " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 85:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:542
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " != " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " != " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 86:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:551
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " < " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " < " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 87:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:560
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " > " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " > " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 88:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:569
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 89:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:573
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " + " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " + " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 90:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:582
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " - " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " - " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 92:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:592
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " ^ " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " ^ " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 93:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:601
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 94:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:605
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " * " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " * " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 95:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:614
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " / " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " / " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 96:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:623
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " % " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " % " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 98:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:634
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 99:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:638
		{
			parserVAL.varid = parserDollar[2].varid
		}
	case 100:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:643
		{
			if !prep {
				parserVAL.varid = strconv.Itoa(parserDollar[1].num)
			}
		}
	case 101:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:649
		{
			if !prep {
				cmp.addUsedVar(parserDollar[1].ident)
				T_INT.match(cmp.typeOf(parserDollar[1].ident))
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].ident)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].ident)
				parserVAL.varid = tmp
			}
		}
	case 102:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:660
		{
			if !prep {
				cmp.addUsedVar(parserDollar[1].ident)
				T_INTA.match(cmp.typeOf(parserDollar[1].ident))
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].ident + "[" + parserDollar[3].varid + "]")
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].ident + "[" + parserDollar[3].varid + "]")
				parserVAL.varid = tmp
			}
		}
	}
	goto parserstack /* stack new state and value */
}
