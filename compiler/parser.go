// Code generated by goyacc -o parser.go -p parser parser.y. DO NOT EDIT.

//line parser.y:2
package main

import __yyfmt__ "fmt"

//line parser.y:2

import (
	"strconv"
)

//line parser.y:9
type parserSymType struct {
	yys      int
	num      int
	ident    string
	varid    string
	tag      int
	arrentry arrentry
}

const NUM = 57346
const IDENT = 57347
const PLUS = 57348
const MINUS = 57349
const XOR = 57350
const MULT = 57351
const DIV = 57352
const MOD = 57353
const AND = 57354
const OR = 57355
const BITAND = 57356
const BITOR = 57357
const LEQ = 57358
const GEQ = 57359
const NEQ = 57360
const EQ = 57361
const LES = 57362
const GRT = 57363
const LSB = 57364
const RSB = 57365
const LCB = 57366
const RCB = 57367
const COMMA = 57368
const LPR = 57369
const RPR = 57370
const PROCEDURE = 57371
const MAIN = 57372
const INT = 57373
const IF = 57374
const THEN = 57375
const ELSE = 57376
const FI = 57377
const FROM = 57378
const DO = 57379
const LOOP = 57380
const UNTIL = 57381
const LOCAL = 57382
const DELOCAL = 57383
const CALL = 57384
const UNCALL = 57385
const SKIP = 57386
const BEGIN = 57387
const END = 57388
const P = 57389
const V = 57390
const SYNC = 57391
const WAIT = 57392
const ACQUIRE = 57393

var parserToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"NUM",
	"IDENT",
	"PLUS",
	"MINUS",
	"XOR",
	"MULT",
	"DIV",
	"MOD",
	"AND",
	"OR",
	"BITAND",
	"BITOR",
	"LEQ",
	"GEQ",
	"NEQ",
	"EQ",
	"LES",
	"GRT",
	"LSB",
	"RSB",
	"LCB",
	"RCB",
	"COMMA",
	"LPR",
	"RPR",
	"PROCEDURE",
	"MAIN",
	"INT",
	"IF",
	"THEN",
	"ELSE",
	"FI",
	"FROM",
	"DO",
	"LOOP",
	"UNTIL",
	"LOCAL",
	"DELOCAL",
	"CALL",
	"UNCALL",
	"SKIP",
	"BEGIN",
	"END",
	"P",
	"V",
	"SYNC",
	"WAIT",
	"ACQUIRE",
}

var parserStatenames = [...]string{}

const parserEofCode = 1
const parserErrCode = 2
const parserInitialStackSize = 16

//line parser.y:673

//line yacctab:1
var parserExca = [...]int8{
	-1, 1,
	1, -1,
	-2, 0,
}

const parserPrivate = 57344

const parserLast = 213

var parserAct = [...]uint8{
	91, 184, 185, 171, 13, 164, 46, 106, 96, 94,
	14, 83, 78, 65, 66, 9, 188, 14, 93, 36,
	44, 95, 193, 187, 203, 197, 92, 202, 182, 192,
	62, 117, 67, 10, 99, 100, 6, 170, 82, 138,
	51, 172, 107, 84, 112, 117, 158, 55, 45, 119,
	120, 122, 121, 123, 124, 167, 134, 98, 117, 68,
	69, 70, 37, 38, 39, 59, 60, 85, 116, 81,
	50, 198, 109, 101, 102, 103, 58, 57, 40, 56,
	75, 76, 24, 54, 86, 14, 53, 110, 52, 113,
	114, 115, 125, 126, 128, 117, 104, 105, 111, 133,
	118, 127, 129, 130, 131, 7, 4, 132, 195, 26,
	165, 135, 11, 27, 32, 141, 139, 29, 79, 28,
	137, 20, 87, 140, 80, 49, 136, 31, 30, 144,
	145, 146, 147, 148, 149, 159, 48, 143, 154, 155,
	156, 157, 160, 161, 142, 162, 166, 150, 151, 152,
	153, 41, 42, 43, 34, 33, 12, 63, 108, 77,
	61, 163, 201, 181, 173, 47, 206, 194, 169, 174,
	183, 175, 199, 190, 177, 178, 179, 168, 176, 74,
	180, 73, 72, 71, 186, 90, 89, 88, 14, 191,
	189, 23, 22, 21, 19, 196, 18, 17, 16, 200,
	15, 64, 204, 205, 35, 8, 3, 207, 5, 2,
	1, 25, 97,
}

var parserPact = [...]int16{
	-1000, -1000, 7, -16, -1000, 7, 151, 77, -16, 150,
	149, -1000, -1000, -1000, 77, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, 56, 145, -1000, -1000, -1000, -1000,
	131, 120, -1000, 48, -1000, 13, -1000, 69, 67, 64,
	-1000, 60, 58, 57, -1000, -1000, -1000, -1, -1000, -1000,
	153, -17, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, 113, 119, 46, 10, 17, 62, 117, -1000, -1000,
	-1000, 30, 30, 30, 30, -1000, -1000, -1000, 16, -1000,
	53, -1000, 77, -1000, -17, -1000, 21, -1000, 30, 30,
	30, 45, 88, 33, 86, 93, -1000, -1000, 30, -1000,
	34, 82, 82, 82, -1000, -1000, -1000, 113, 12, -1000,
	-1000, 17, 110, 82, 82, 82, -1000, 30, 30, 30,
	30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
	30, 30, 30, 18, 30, -1000, -1000, 16, 105, -1000,
	-1000, -1000, 88, 33, 86, 86, 86, 86, 86, 86,
	93, 93, 93, 93, -1000, -1000, -1000, -1000, -1000, 32,
	-1000, -1000, -1000, 9, 15, -1000, -1000, -1000, 30, -1000,
	-1000, -1000, 105, 30, 82, 30, 15, 82, -5, 82,
	-1000, 77, 77, -14, -25, 77, -1000, 77, -2, -1000,
	-12, -1000, 103, 77, -13, 52, -1000, 77, -1000, -8,
	-15, 30, 30, -1000, 82, 82, 30, 82,
}

var parserPgo = [...]uint8{
	0, 212, 0, 26, 18, 9, 21, 8, 20, 211,
	6, 210, 209, 106, 208, 206, 105, 4, 205, 204,
	201, 13, 11, 2, 1, 200, 198, 197, 196, 194,
	193, 192, 191, 187, 186, 185, 183, 182, 181, 179,
	177, 175, 173, 172, 171, 170, 167, 166, 165, 164,
	163, 162, 161, 5, 3, 160, 159, 12, 158, 7,
}

var parserR1 = [...]int8{
	0, 11, 13, 13, 15, 12, 16, 16, 18, 18,
	18, 19, 14, 20, 20, 22, 22, 21, 21, 21,
	17, 17, 24, 23, 23, 23, 23, 23, 23, 23,
	23, 23, 33, 25, 34, 25, 35, 25, 36, 9,
	37, 26, 38, 26, 39, 26, 40, 41, 42, 43,
	27, 8, 44, 45, 46, 47, 28, 48, 49, 50,
	51, 30, 52, 52, 54, 54, 53, 31, 32, 55,
	29, 58, 57, 56, 59, 59, 10, 2, 2, 3,
	3, 4, 4, 4, 4, 4, 4, 4, 5, 5,
	5, 5, 5, 6, 6, 6, 6, 6, 7, 7,
	1, 1, 1,
}

var parserR2 = [...]int8{
	0, 2, 2, 0, 0, 3, 2, 0, 2, 2,
	5, 0, 7, 2, 0, 3, 0, 2, 4, 2,
	2, 0, 2, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 0, 6, 0, 6, 0, 6, 0, 6,
	0, 5, 0, 5, 0, 5, 0, 0, 0, 0,
	18, 0, 0, 0, 0, 0, 19, 0, 0, 0,
	0, 17, 2, 0, 3, 0, 1, 2, 2, 0,
	4, 0, 5, 2, 3, 0, 0, 1, 3, 1,
	3, 1, 3, 3, 3, 3, 3, 3, 1, 3,
	3, 3, 3, 1, 3, 3, 3, 3, 1, 3,
	1, 1, 4,
}

var parserChk = [...]int16{
	-1000, -11, -12, -15, -13, -14, 29, -16, -18, 31,
	49, -13, 5, -17, -23, -25, -26, -27, -28, -29,
	44, -30, -31, -32, 5, -9, 32, 36, 42, 40,
	51, 50, -16, 5, 5, -19, -17, 6, 7, 8,
	22, 6, 7, 8, -8, -8, -10, -48, 5, 5,
	22, 27, 19, 19, 19, -10, 19, 19, 19, -8,
	-8, -55, 31, 4, -20, -21, 31, 49, -10, -10,
	-10, -36, -37, -38, -39, -8, -8, -56, -57, 5,
	5, 23, 28, -22, 26, 5, 22, 5, -33, -34,
	-35, -2, -3, -4, -5, -6, -7, -1, 27, 4,
	5, -2, -2, -2, -8, -8, -59, 26, -58, 19,
	-17, -21, 23, -2, -2, -2, 23, 13, 12, 16,
	17, 19, 18, 20, 21, 6, 7, 15, 8, 9,
	10, 11, 14, -2, 22, -10, -8, -57, 27, -10,
	-22, 5, -3, -4, -5, -5, -5, -5, -5, -5,
	-6, -6, -6, -6, -7, -7, -7, -7, 28, -2,
	-10, -10, -59, -52, -53, 5, -10, 23, -40, -10,
	28, -54, 26, -49, -2, -44, -53, -2, -41, -2,
	-54, -50, 33, -45, -24, -23, -24, 37, 41, -17,
	-42, -24, 31, 34, -46, 5, -24, 38, 19, -43,
	-24, -51, 35, 39, -2, -2, -47, -2,
}

var parserDef = [...]int8{
	4, -2, 3, 7, 1, 3, 0, 21, 7, 0,
	0, 2, 11, 5, 21, 23, 24, 25, 26, 27,
	28, 29, 30, 31, 0, 0, 51, 51, 76, 57,
	0, 0, 6, 8, 9, 0, 20, 0, 0, 0,
	76, 0, 0, 0, 51, 51, 69, 0, 67, 68,
	0, 14, 76, 76, 76, 38, 40, 42, 44, 51,
	51, 0, 0, 0, 0, 16, 0, 0, 32, 34,
	36, 0, 0, 0, 0, 51, 51, 70, 75, 71,
	0, 10, 21, 13, 0, 17, 0, 19, 0, 0,
	0, 0, 77, 79, 81, 88, 93, 98, 0, 100,
	101, 41, 43, 45, 76, 51, 73, 0, 0, 76,
	12, 16, 0, 33, 35, 37, 39, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 76, 76, 75, 63, 76,
	15, 18, 78, 80, 82, 83, 84, 85, 86, 87,
	89, 90, 91, 92, 94, 95, 96, 97, 99, 0,
	46, 76, 74, 0, 65, 66, 58, 102, 0, 52,
	72, 62, 0, 0, 47, 0, 65, 59, 0, 53,
	64, 0, 0, 0, 0, 21, 48, 0, 0, 22,
	0, 54, 0, 0, 0, 0, 49, 0, 60, 0,
	0, 0, 0, 55, 61, 50, 0, 56,
}

var parserTok1 = [...]int8{
	1,
}

var parserTok2 = [...]int8{
	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
	42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
}

var parserTok3 = [...]int8{
	0,
}

var parserErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	parserDebug        = 0
	parserErrorVerbose = false
)

type parserLexer interface {
	Lex(lval *parserSymType) int
	Error(s string)
}

type parserParser interface {
	Parse(parserLexer) int
	Lookahead() int
}

type parserParserImpl struct {
	lval  parserSymType
	stack [parserInitialStackSize]parserSymType
	char  int
}

func (p *parserParserImpl) Lookahead() int {
	return p.char
}

func parserNewParser() parserParser {
	return &parserParserImpl{}
}

const parserFlag = -1000

func parserTokname(c int) string {
	if c >= 1 && c-1 < len(parserToknames) {
		if parserToknames[c-1] != "" {
			return parserToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func parserStatname(s int) string {
	if s >= 0 && s < len(parserStatenames) {
		if parserStatenames[s] != "" {
			return parserStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func parserErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !parserErrorVerbose {
		return "syntax error"
	}

	for _, e := range parserErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + parserTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := int(parserPact[state])
	for tok := TOKSTART; tok-1 < len(parserToknames); tok++ {
		if n := base + tok; n >= 0 && n < parserLast && int(parserChk[int(parserAct[n])]) == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if parserDef[state] == -2 {
		i := 0
		for parserExca[i] != -1 || int(parserExca[i+1]) != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; parserExca[i] >= 0; i += 2 {
			tok := int(parserExca[i])
			if tok < TOKSTART || parserExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if parserExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += parserTokname(tok)
	}
	return res
}

func parserlex1(lex parserLexer, lval *parserSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = int(parserTok1[0])
		goto out
	}
	if char < len(parserTok1) {
		token = int(parserTok1[char])
		goto out
	}
	if char >= parserPrivate {
		if char < parserPrivate+len(parserTok2) {
			token = int(parserTok2[char-parserPrivate])
			goto out
		}
	}
	for i := 0; i < len(parserTok3); i += 2 {
		token = int(parserTok3[i+0])
		if token == char {
			token = int(parserTok3[i+1])
			goto out
		}
	}

out:
	if token == 0 {
		token = int(parserTok2[1]) /* unknown char */
	}
	if parserDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", parserTokname(token), uint(char))
	}
	return char, token
}

func parserParse(parserlex parserLexer) int {
	return parserNewParser().Parse(parserlex)
}

func (parserrcvr *parserParserImpl) Parse(parserlex parserLexer) int {
	var parsern int
	var parserVAL parserSymType
	var parserDollar []parserSymType
	_ = parserDollar // silence set and not used
	parserS := parserrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	parserstate := 0
	parserrcvr.char = -1
	parsertoken := -1 // parserrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		parserstate = -1
		parserrcvr.char = -1
		parsertoken = -1
	}()
	parserp := -1
	goto parserstack

ret0:
	return 0

ret1:
	return 1

parserstack:
	/* put a state and value onto the stack */
	if parserDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", parserTokname(parsertoken), parserStatname(parserstate))
	}

	parserp++
	if parserp >= len(parserS) {
		nyys := make([]parserSymType, len(parserS)*2)
		copy(nyys, parserS)
		parserS = nyys
	}
	parserS[parserp] = parserVAL
	parserS[parserp].yys = parserstate

parsernewstate:
	parsern = int(parserPact[parserstate])
	if parsern <= parserFlag {
		goto parserdefault /* simple state */
	}
	if parserrcvr.char < 0 {
		parserrcvr.char, parsertoken = parserlex1(parserlex, &parserrcvr.lval)
	}
	parsern += parsertoken
	if parsern < 0 || parsern >= parserLast {
		goto parserdefault
	}
	parsern = int(parserAct[parsern])
	if int(parserChk[parsern]) == parsertoken { /* valid shift */
		parserrcvr.char = -1
		parsertoken = -1
		parserVAL = parserrcvr.lval
		parserstate = parsern
		if Errflag > 0 {
			Errflag--
		}
		goto parserstack
	}

parserdefault:
	/* default state action */
	parsern = int(parserDef[parserstate])
	if parsern == -2 {
		if parserrcvr.char < 0 {
			parserrcvr.char, parsertoken = parserlex1(parserlex, &parserrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if parserExca[xi+0] == -1 && int(parserExca[xi+1]) == parserstate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			parsern = int(parserExca[xi+0])
			if parsern < 0 || parsern == parsertoken {
				break
			}
		}
		parsern = int(parserExca[xi+1])
		if parsern < 0 {
			goto ret0
		}
	}
	if parsern == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			parserlex.Error(parserErrorMessage(parserstate, parsertoken))
			Nerrs++
			if parserDebug >= 1 {
				__yyfmt__.Printf("%s", parserStatname(parserstate))
				__yyfmt__.Printf(" saw %s\n", parserTokname(parsertoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for parserp >= 0 {
				parsern = int(parserPact[parserS[parserp].yys]) + parserErrCode
				if parsern >= 0 && parsern < parserLast {
					parserstate = int(parserAct[parsern]) /* simulate a shift of "error" */
					if int(parserChk[parserstate]) == parserErrCode {
						goto parserstack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if parserDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", parserS[parserp].yys)
				}
				parserp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if parserDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", parserTokname(parsertoken))
			}
			if parsertoken == parserEofCode {
				goto ret1
			}
			parserrcvr.char = -1
			parsertoken = -1
			goto parsernewstate /* try again in the same state */
		}
	}

	/* reduction by production parsern */
	if parserDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", parsern, parserStatname(parserstate))
	}

	parsernt := parsern
	parserpt := parserp
	_ = parserpt // guard against "declared and not used"

	parserp -= int(parserR2[parsern])
	// parserp is now the index of $0. Perform the default action. Iff the
	// reduced production is ε, $1 is possibly out of range.
	if parserp+1 >= len(parserS) {
		nyys := make([]parserSymType, len(parserS)*2)
		copy(nyys, parserS)
		parserS = nyys
	}
	parserVAL = parserS[parserp+1]

	/* consult goto table to find next state */
	parsern = int(parserR1[parsern])
	parserg := int(parserPgo[parsern])
	parserj := parserg + parserS[parserp].yys + 1

	if parserj >= parserLast {
		parserstate = int(parserAct[parserg])
	} else {
		parserstate = int(parserAct[parserj])
		if int(parserChk[parserstate]) != -parsern {
			parserstate = int(parserAct[parserg])
		}
	}
	// dummy call; replaced with literal code
	switch parsernt {

	case 4:
		parserDollar = parserS[parserpt-0 : parserpt+1]
//line parser.y:31
		{
			if !prep {
				cmp.exec("begin main")
			}
		}
	case 5:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:38
		{
			if !prep {
				cmp.exec("end main")
			}
		}
	case 8:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:49
		{
			if !prep {
				cmp.registerGlobal(parserDollar[2].ident, T_INT)
				cmp.exec("set #" + parserDollar[2].ident + " " + cmp.getMem(1))
			}
		}
	case 9:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:55
		{
			if !prep {
				cmp.registerGlobal(parserDollar[2].ident, T_SYNC)
				cmp.exec("set #" + parserDollar[2].ident + " " + cmp.getMem(1))
			}
		}
	case 10:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:62
		{
			if !prep {
				cmp.registerGlobal(parserDollar[2].ident, T_INTA)
				cmp.exec("set #" + parserDollar[2].ident + " " + cmp.getMem(parserDollar[4].num))
			}
		}
	case 11:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:70
		{
			if prep {
				cmp.declpname = parserDollar[2].ident
			} else {
				cmp.setProc(parserDollar[2].ident)
				cmp.exec("begin " + parserDollar[2].ident)
			}
		}
	case 12:
		parserDollar = parserS[parserpt-7 : parserpt+1]
//line parser.y:79
		{
			if !prep {
				cmp.exec("end " + parserDollar[2].ident)
			}
		}
	case 17:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:93
		{
			if prep {
				cmp.registerDecl(parserDollar[2].ident, T_INT)
			}
		}
	case 18:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:99
		{
			if prep {
				cmp.registerDecl(parserDollar[4].ident, T_INTA)
			}
		}
	case 19:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:105
		{
			if prep {
				cmp.registerDecl(parserDollar[2].ident, T_SYNC)
			}
		}
	case 32:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:127
		{
			if !prep {
				cmp.beginRecord(parserDollar[4].tag)
			}
		}
	case 33:
		parserDollar = parserS[parserpt-6 : parserpt+1]
//line parser.y:133
		{
			if !prep {
				cmp.endRecord(parserDollar[4].tag)
				cmp.lockrecord(parserDollar[4].tag)
				cmp.execrecord(parserDollar[4].tag)
				cmp.exec(parserDollar[1].ident + " += " + parserDollar[6].varid)
				cmp.unexecrecord(parserDollar[4].tag)
				cmp.unlockrecord(parserDollar[4].tag)
			}

		}
	case 34:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:145
		{
			if !prep {
				cmp.beginRecord(parserDollar[4].tag)
			}
		}
	case 35:
		parserDollar = parserS[parserpt-6 : parserpt+1]
//line parser.y:151
		{
			if !prep {
				cmp.endRecord(parserDollar[4].tag)
				cmp.lockrecord(parserDollar[4].tag)
				cmp.execrecord(parserDollar[4].tag)
				cmp.exec(parserDollar[1].ident + " -= " + parserDollar[6].varid)
				cmp.unexecrecord(parserDollar[4].tag)
				cmp.unlockrecord(parserDollar[4].tag)
			}

		}
	case 36:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:163
		{
			if !prep {
				cmp.beginRecord(parserDollar[4].tag)
			}
		}
	case 37:
		parserDollar = parserS[parserpt-6 : parserpt+1]
//line parser.y:169
		{
			if !prep {
				cmp.endRecord(parserDollar[4].tag)
				cmp.lockrecord(parserDollar[4].tag)
				cmp.execrecord(parserDollar[4].tag)
				cmp.exec(parserDollar[1].ident + " ^= " + parserDollar[6].varid)
				cmp.unexecrecord(parserDollar[4].tag)
				cmp.unlockrecord(parserDollar[4].tag)
			}

		}
	case 38:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:182
		{
			if !prep {
				cmp.beginRecord(parserDollar[3].tag)
			}
		}
	case 39:
		parserDollar = parserS[parserpt-6 : parserpt+1]
//line parser.y:188
		{
			if !prep {
				cmp.endRecord(parserDollar[3].tag)
				parserVAL.arrentry = arrentry{parserDollar[1].ident + "[" + parserDollar[5].varid + "]", parserDollar[3].tag}
			}
		}
	case 40:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:196
		{
			if !prep {
				cmp.beginRecord(parserDollar[1].arrentry.tag)
			}
		}
	case 41:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:202
		{
			if !prep {
				cmp.endRecord(parserDollar[1].arrentry.tag)
				cmp.lockrecord(parserDollar[1].arrentry.tag)
				cmp.execrecord(parserDollar[1].arrentry.tag)
				cmp.exec(parserDollar[1].arrentry.val + " += " + parserDollar[5].varid)
				cmp.unexecrecord(parserDollar[1].arrentry.tag)
				cmp.unlockrecord(parserDollar[1].arrentry.tag)
			}

		}
	case 42:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:214
		{
			if !prep {
				cmp.beginRecord(parserDollar[1].arrentry.tag)
			}
		}
	case 43:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:220
		{
			if !prep {
				cmp.endRecord(parserDollar[1].arrentry.tag)
				cmp.lockrecord(parserDollar[1].arrentry.tag)
				cmp.execrecord(parserDollar[1].arrentry.tag)
				cmp.exec(parserDollar[1].arrentry.val + " -= " + parserDollar[5].varid)
				cmp.unexecrecord(parserDollar[1].arrentry.tag)
				cmp.unlockrecord(parserDollar[1].arrentry.tag)
			}

		}
	case 44:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:232
		{
			if !prep {
				cmp.beginRecord(parserDollar[1].arrentry.tag)
			}
		}
	case 45:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:238
		{
			if !prep {
				cmp.endRecord(parserDollar[1].arrentry.tag)
				cmp.lockrecord(parserDollar[1].arrentry.tag)
				cmp.execrecord(parserDollar[1].arrentry.tag)
				cmp.exec(parserDollar[1].arrentry.val + " ^= " + parserDollar[5].varid)
				cmp.unexecrecord(parserDollar[1].arrentry.tag)
				cmp.unlockrecord(parserDollar[1].arrentry.tag)
			}

		}
	case 46:
		parserDollar = parserS[parserpt-7 : parserpt+1]
//line parser.y:251
		{
			if !prep {
				cmp.beginRecord(parserDollar[6].tag)
			}
		}
	case 47:
		parserDollar = parserS[parserpt-9 : parserpt+1]
//line parser.y:257
		{
			if !prep {
				cmp.endRecord(parserDollar[6].tag)
				cmp.lockrecord(parserDollar[6].tag)
				cmp.execrecord(parserDollar[6].tag)
				cmp.exec(parserDollar[9].varid + " -> " + parserDollar[2].varid + ";" + parserDollar[3].varid)
				cmp.exec(parserDollar[2].varid + " <-")
				cmp.unexecrecord(parserDollar[6].tag)
				cmp.unlockrecord(parserDollar[6].tag)
			}
		}
	case 48:
		parserDollar = parserS[parserpt-12 : parserpt+1]
//line parser.y:269
		{
			if !prep {
				cmp.lockrecord(parserDollar[7].tag)
				cmp.execrecord(parserDollar[7].tag)
				cmp.exec("-> " + parserDollar[4].varid)
				cmp.exec(parserDollar[3].varid + " <-")
				cmp.unexecrecord(parserDollar[6].tag)
				cmp.unlockrecord(parserDollar[6].tag)
			}
		}
	case 49:
		parserDollar = parserS[parserpt-15 : parserpt+1]
//line parser.y:280
		{
			if !prep {
				cmp.lockrecord(parserDollar[7].tag)
				cmp.execrecord(parserDollar[7].tag)
				cmp.exec("-> " + parserDollar[5].varid)
				cmp.beginRecord(parserDollar[7].tag)
			}
		}
	case 50:
		parserDollar = parserS[parserpt-18 : parserpt+1]
//line parser.y:289
		{
			if !prep {
				cmp.endRecord(parserDollar[7].tag)
				cmp.exec(parserDollar[4].varid + ";" + parserDollar[5].varid + " <- " + parserDollar[18].varid)
				cmp.unexecrecord(parserDollar[7].tag)
				cmp.unlockrecord(parserDollar[7].tag)
			}
		}
	case 51:
		parserDollar = parserS[parserpt-0 : parserpt+1]
//line parser.y:299
		{
			if !prep {
				parserVAL.varid = cmp.getLabel()
			}
		}
	case 52:
		parserDollar = parserS[parserpt-8 : parserpt+1]
//line parser.y:306
		{
			if !prep {
				cmp.beginRecord(parserDollar[7].tag)
			}
		}
	case 53:
		parserDollar = parserS[parserpt-10 : parserpt+1]
//line parser.y:312
		{
			if !prep {
				cmp.endRecord(parserDollar[7].tag)
				cmp.lockrecord(parserDollar[7].tag)
				cmp.execrecord(parserDollar[7].tag)
				cmp.exec("-> " + parserDollar[2].varid)
				cmp.exec(parserDollar[2].varid + ";" + parserDollar[6].varid + " <- " + parserDollar[10].varid)
				cmp.unexecrecord(parserDollar[7].tag)
				cmp.unlockrecord(parserDollar[7].tag)
			}
		}
	case 54:
		parserDollar = parserS[parserpt-13 : parserpt+1]
//line parser.y:324
		{
			if !prep {
				cmp.exec("-> " + parserDollar[3].varid)
				cmp.exec(parserDollar[5].varid + " <-")
				cmp.unexecrecord(parserDollar[8].tag)
				cmp.unlockrecord(parserDollar[8].tag)
			}
		}
	case 55:
		parserDollar = parserS[parserpt-17 : parserpt+1]
//line parser.y:333
		{
			if !prep {
				cmp.lockrecord(parserDollar[7].tag)
				cmp.execrecord(parserDollar[7].tag)
				cmp.exec("-> " + parserDollar[6].varid)
				cmp.exec(parserDollar[3].varid + " <-")
				cmp.beginRecord(parserDollar[8].tag)
			}
		}
	case 56:
		parserDollar = parserS[parserpt-19 : parserpt+1]
//line parser.y:343
		{
			if !prep {
				cmp.endRecord(parserDollar[8].tag)
				cmp.lockrecord(parserDollar[8].tag)
				cmp.execrecord(parserDollar[8].tag)
				cmp.exec(parserDollar[19].varid + " -> " + parserDollar[4].varid + ";" + parserDollar[5].varid)
				cmp.exec(parserDollar[4].varid + " <-")
				cmp.unexecrecord(parserDollar[8].tag)
				cmp.unlockrecord(parserDollar[8].tag)
			}
		}
	case 57:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:357
		{
			if !prep {
				cmp.exec("push")
				cmp.indent()
			}
		}
	case 58:
		parserDollar = parserS[parserpt-7 : parserpt+1]
//line parser.y:364
		{
			if !prep {
				cmp.registerLocal(parserDollar[4].ident)
				cmp.beginRecord(parserDollar[6].tag)
			}
		}
	case 59:
		parserDollar = parserS[parserpt-9 : parserpt+1]
//line parser.y:371
		{
			if !prep {
				cmp.endRecord(parserDollar[6].tag)
				cmp.lockrecord(parserDollar[6].tag)
				cmp.execrecord(parserDollar[6].tag)
				cmp.exec("$" + parserDollar[4].ident + " += " + parserDollar[9].varid)
				cmp.unexecrecord(parserDollar[6].tag)
				cmp.unlockrecord(parserDollar[6].tag)
			}
		}
	case 60:
		parserDollar = parserS[parserpt-15 : parserpt+1]
//line parser.y:382
		{
			if !prep {
				cmp.beginRecord(parserDollar[7].tag)
			}
		}
	case 61:
		parserDollar = parserS[parserpt-17 : parserpt+1]
//line parser.y:388
		{
			if !prep {
				cmp.endRecord(parserDollar[7].tag)
				cmp.lockrecord(parserDollar[7].tag)
				cmp.execrecord(parserDollar[7].tag)
				cmp.exec("$" + parserDollar[14].ident + " -= " + parserDollar[17].varid)
				cmp.unexecrecord(parserDollar[7].tag)
				cmp.unlockrecord(parserDollar[7].tag)
				cmp.exec("pop")
				cmp.unindent()
			}
		}
	case 66:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:409
		{
			if !prep {
				i, t := cmp.getProcArgs(cmp.callpname)
				t[cmp.argindex].match(cmp.typeOf(parserDollar[1].ident))
				cmp.exec("set $" + i[cmp.argindex] + "@" + strconv.Itoa(len(cmp.procrec)-1) + " " + parserDollar[1].ident)
				cmp.unexec("unset $" + i[cmp.argindex] + "@" + strconv.Itoa(len(cmp.procrec)-1) + " " + parserDollar[1].ident)
				cmp.argindex++
			}
		}
	case 67:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:420
		{
			if !prep {
				cmp.exec("V " + parserDollar[2].ident)
			}
		}
	case 68:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:426
		{
			if !prep {
				cmp.exec("P " + parserDollar[2].ident)
			}
		}
	case 69:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:433
		{
			if !prep {
				cmp.procrec = make([]string, 0)
				cmp.beginRecord(parserDollar[2].tag)
			}
		}
	case 70:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:440
		{
			if !prep {
				cmp.endRecord(parserDollar[2].tag)
				cmp.execrecord(parserDollar[2].tag)
				s := ""
				for i, p := range cmp.procrec {
					if i != 0 {
						s += ", "
					}
					s += p
				}
				cmp.exec("call " + s)
				cmp.unexecrecord(parserDollar[2].tag)
				cmp.procrec = make([]string, 0)
			}
		}
	case 71:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:458
		{
			if !prep {
				cmp.callpname = parserDollar[1].ident
				cmp.procrec = append(cmp.procrec, parserDollar[1].ident)
				cmp.argindex = 0
			}
		}
	case 72:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:466
		{
			if !prep {
				cmp.argindex = 0
			}
		}
	case 76:
		parserDollar = parserS[parserpt-0 : parserpt+1]
//line parser.y:478
		{
			parserVAL.tag = cmp.getTag()
		}
	case 77:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:483
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 78:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:487
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " ||" + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " ||" + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 79:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:496
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 80:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:500
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " && " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " && " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 81:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:510
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 82:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:514
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " <= " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " <= " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 83:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:523
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " >= " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " >= " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 84:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:532
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " == " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " == " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 85:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:541
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " != " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " != " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 86:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:550
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " < " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " < " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 87:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:559
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " > " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " > " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 88:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:568
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 89:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:572
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " + " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " + " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 90:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:581
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " - " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " - " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 92:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:591
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " ^ " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " ^ " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 93:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:600
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 94:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:604
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " * " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " * " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 95:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:613
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " / " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " / " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 96:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:622
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].varid + " % " + parserDollar[3].varid)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].varid + " % " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 98:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:633
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 99:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:637
		{
			parserVAL.varid = parserDollar[2].varid
		}
	case 100:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:642
		{
			if !prep {
				a := strconv.Itoa(parserDollar[1].num)
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + a)
				cmp.unexec("$" + tmp + " -= " + a)
				parserVAL.varid = tmp
			}
		}
	case 101:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:652
		{
			if !prep {
				cmp.addUsedVar(parserDollar[1].ident)
				T_INT.match(cmp.typeOf(parserDollar[1].ident))
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].ident)
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].ident)
				parserVAL.varid = tmp
			}
		}
	case 102:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:663
		{
			if !prep {
				cmp.addUsedVar(parserDollar[1].ident)
				T_INTA.match(cmp.typeOf(parserDollar[1].ident))
				tmp := cmp.getTmp()
				cmp.exec("$" + tmp + " += " + parserDollar[1].ident + "[" + parserDollar[3].varid + "]")
				cmp.unexec("$" + tmp + " -= " + parserDollar[1].ident + "[" + parserDollar[3].varid + "]")
				parserVAL.varid = tmp
			}
		}
	}
	goto parserstack /* stack new state and value */
}
